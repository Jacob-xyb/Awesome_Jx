# 字符编码

## 字符编码的作用

计算机只认识0和1组成的二进制序列，因此任何文件中的内容要想被计算机识别或者想存储在计算机上都需要转换为二进制序列。那么字符与二进制序列怎么进行想换转换呢？于是人们尝试建立一个表格来***存储一个字符与一个二进制序列的对应关系***。

- **编码** 将字符转换为对应的二进制序列的过程叫做字符编码
- **解码** 将二进制序列转换为对应的字符的过程叫做字符解码

## 字符编码的简单发展过程

### ASCII码诞生

最早建立这个字符与十进制数字对应的关系的是美国，这张表被称为ASCII码(American Standard Code for Information Interface, 美国标准信息交换代码)。ASCII码是基于拉丁字母的一套电脑编程系统，主要用于显示现代英语和其他西欧语言。它被设计为用1个字节来表示一个字符，所以ASCII码表最多只能表示2**8=256个字符。实际上ASCII码表中只有128个字符，剩余的128个字符是预留扩展用的。

![img](https://images2015.cnblogs.com/blog/1063221/201611/1063221-20161122155336925-2078937469.jpg)

###  GBK等各国编码诞生

随着计算机的普及和发展，很过国家都开始使用计算机。大家发现ASCII码预留的128个位置根本无法存储自己国家的文字和字符，因此各个国家开始制定各自的字符编码表，其中中国的的字符编码表有GB2312和GBK。

###  Unicode诞生

后来随着世界互联网的形成和发展，各国的人们开始有了互相交流的需要。但是这个时候就存在一个问题，每个国家所使用的字符编码表都是不同的。

这个时候，人们希望有一个世界统一的字符编码表来存放所有国家所使用的文字和符号，这就是Unicode。Unicode又被称为 统一码、万国码、单一码，它是为了解决传统的字符编码方案的局限性而产生的，它为每种语言中的每个字符设定了统一并且为之一的二进制编码。Unicode规定所有的字符和符号最少由2个字节（16位）来表示，所以Unicode码可以表示的最少字符个数为2**16=65536。

### UTF-8诞生

为什么已经有了Unicode还要UTF-8呢？这是由于当时存储设备是非常昂贵的，而Unicode中规定所有字符最少要由2个字节表示。人们认为像原来ASCII码中的字符用1个字节就可以了，因此人们决定创建一个新的字符编码来节省存储空间。UTF-8是对Unicode编码的压缩和优化，它不在要求最少使用2个字节，而是将所有字符和符号进行分类：

- ascii码中的内容用1个字节保存
- 欧洲的字符用2个字节保存
- 东亚的字符用3个字节保存
- ...

UTF-8是目前最常用，也是被推荐使用的字符编码。

# 计算机运算

## 浮点数运算

### 什么是浮点数

在计算机系统的发展过程中，曾经提出过多种方法表达实数。

1. 定点数(Fixed Point Number)

典型的比如相对于浮点数的`定点数（Fixed Point Number）`。在这种表达方式中，小数点固定的位于实数所有数字中间的某个位置。

货币的表达就可以使用这种方式，比如 99.00 或者 00.99 可以用于表达具有四位精度（Precision），小数点后有两位的货币值。

由于小数点位置固定，所以可以直接用四位数值来表达相应的数值。SQL 中的 NUMBER 数据类型就是利用定点数来定义的。

2. 有理数表达

还有一种提议的表达方式为有理数表达方式，即用两个整数的比值来表达实数。

定点数表达法的缺点在于其形式过于僵硬，固定的小数点位置决定了固定位数的整数部分和小数部分，不利于同时表达特别大的数或者特别小的数。最终，绝大多数现代的计算机系统采纳了所谓的浮点数表达方式。

3. 浮点数表达

浮点数表达方式， 这种表达方式利用`科学计数法`来表达实数，即用`一个尾数（Mantissa ）`，`一个基数（Base）`，`一个指数（Exponent）`以及`一个表示正负的符号`来表达实数。比如 123.45 用十进制科学计数法可以表达为 1.2345 × 10^2 ，其中 1.2345 为尾数，10 为基数，2 为指数。浮点数利用指数达到了浮动小数点的效果，从而可以灵活地表达更大范围的实数。

提示: 尾数有时也称为有效数字（Significand）。**尾数实际上是有效数字的非正式说法。**

同样的数值可以有多种浮点数表达方式，比如上面例子中的 123.45 可以表达为 12.345 × 10^1，0.12345 × 10^3 或者 1.2345 × 10^2。因为这种多样性，有必要对其加以规范化以达到统一表达的目标。

### 浮点数表达

规范的（Normalized）浮点数表达方式具有如下形式：
$$
d.dd...d \times \beta^e , (0 \le d_i < \beta)
$$
 其中 d.dd...d 即尾数，β 为基数，e 为指数。**尾数中数字的个数称为精度**，在本文中用 p（presion） 来表示。每个数字 d 介于 0 和基数β之间，包括 0。小数点左侧的数字不为 0。

1. 基于**规范表达的浮点数**对应的具体值可由下面的表达式计算而得：(p是精度个数)

$$
\pm(d_0 + d_1\beta^{-1} + \dotsm + d_{p-1}\beta^{-(p-1)})\beta^e , (0 \le d_i < \beta)
$$

  对于十进制的浮点数，即基数 β 等于 10 的浮点数而言，上面的表达式非常容易理解，也很直白。计算机内部的数值表达是基于二进制的。从上面的表达式，我们可以知道，二进制数同样可以有小数点，也同样具有类似于十进制的表达方式。只是此时 β 等于 2，而每个数字 d 只能在 0 和 1 之间取值。

2. 比如二进制数 1001.101 相当于：精度为7

$$
1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times2^{-1} + 0\times2^{-2} + 1\times2^{-3} = 9.625
$$

​	其**规范浮点数**表达为 $1.001101 × 2^3$。

### IEEE （美国电气和电子工程师学会）浮点数

​	计算机中是用**有限的连续字节**保存浮点数的。

　IEEE定义了多种浮点格式，但最常见的是三种类型：**单精度、双精度、扩展双精度**，分别适用于不同的计算要求。一般而言，单精度适合一般计算，双精度适合科学计算，扩展双精度适合高精度计算。一个遵循IEEE 754标准的系统必须支持单精度类型（强制类型）、最好也支持双精度类型（推荐类型），至于扩展双精度类型可以随意。单精度（Single Precision）浮点数是32位（即4字节）的，双精度（Double Precision）浮点数是64位（即8字节）的。

　　保存这些浮点数当然必须有特定的格式，Java 平台上的浮点数类型 float 和 double 采纳了 IEEE 754 标准中所定义的单精度 32 位浮点数和双精度 64 位浮点数的格式。注意: Java 平台还支持该标准定义的两种扩展格式，即 float-extended-exponent 和 double-extended-exponent 扩展格式。这里将不作介绍，有兴趣的读者可以参考相应的参考资料。

　　在 IEEE 标准中，浮点数是将特定长度的连续字节的所有二进制位分割为特定宽度的`符号域`，`指数域`和`尾数域`三个域，其中保存的值分别用于表示给定二进制浮点数中的符号，指数和尾数。这样，通过尾数和可以调节的指数（所以称为"浮点"）就可以表达给定的数值了。

具体的格式参见下面的表格：

|            | 长度 | 符号 | 指数 | 尾数 | 有效位数 | 指数偏移 |    说明     |
| :--------: | :--: | :--: | :--: | :--: | :------: | :------: | :---------: |
|   单精度   | 32位 |  1   |  8   |  23  |    24    |   127    | 有1个隐含位 |
|   双精度   | 64位 |  1   |  11  |  52  |    53    |   1023   | 有1个隐含位 |
| 扩展双精度 | 80位 |  1   |  15  |  64  |    64    |  16383   | 没有隐含位  |

需要特别注意的是，扩展双精度类型没有隐含位，因此它的有效位数与尾数位数一致，而单精度类型和双精度类型均有一个隐含位，因此它的有效位数比位数位数多一个。

- 指数偏移：

  以单精度为例，指数域有8位长度， 最大值 为 $2^8 - 1 = 255$，又因为 $\pm0=0$ ， 所以指数偏移 为 $128 - 1 = 127$。

![img](https://img-blog.csdn.net/20180508103737785?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlcmNlbF96aGFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![img](https://pic4.zhimg.com/80/v2-17da864450fc6f68f1343dac87c5ab72_720w.jpg?source=1940ef5c)

一个float型实数在内存中占4个字节,即32个二进制bit,从低位到高位依次叫第0位到第31位.

这32位可以分为3个部分：**符号位（第31位）**，阶码（第30位到第23位共8位），**尾数（最低23位）**。

1. 符号位

   最高位也就是第31位表示这个实数是正数还是负数,**为0表示正数或0,为1表示负数**.

2. 阶码

   第30位到第23位这8个二进制位表示该实数转化为规格化的二进制实数后的指数与127(127即所谓偏移量)之和即所谓阶码。

