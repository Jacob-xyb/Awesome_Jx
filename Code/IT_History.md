# 字符编码

## 字符编码的作用

计算机只认识0和1组成的二进制序列，因此任何文件中的内容要想被计算机识别或者想存储在计算机上都需要转换为二进制序列。那么字符与二进制序列怎么进行想换转换呢？于是人们尝试建立一个表格来***存储一个字符与一个二进制序列的对应关系***。

- **编码** 将字符转换为对应的二进制序列的过程叫做字符编码
- **解码** 将二进制序列转换为对应的字符的过程叫做字符解码

## 字符编码的简单发展过程

### ASCII码诞生

最早建立这个字符与十进制数字对应的关系的是美国，这张表被称为ASCII码(American Standard Code for Information Interface, 美国标准信息交换代码)。ASCII码是基于拉丁字母的一套电脑编程系统，主要用于显示现代英语和其他西欧语言。它被设计为用1个字节来表示一个字符，所以ASCII码表最多只能表示2**8=256个字符。实际上ASCII码表中只有128个字符，剩余的128个字符是预留扩展用的。

![img](https://images2015.cnblogs.com/blog/1063221/201611/1063221-20161122155336925-2078937469.jpg)

###  GBK等各国编码诞生

随着计算机的普及和发展，很过国家都开始使用计算机。大家发现ASCII码预留的128个位置根本无法存储自己国家的文字和字符，因此各个国家开始制定各自的字符编码表，其中中国的的字符编码表有GB2312和GBK。

###  Unicode诞生

后来随着世界互联网的形成和发展，各国的人们开始有了互相交流的需要。但是这个时候就存在一个问题，每个国家所使用的字符编码表都是不同的。

这个时候，人们希望有一个世界统一的字符编码表来存放所有国家所使用的文字和符号，这就是Unicode。Unicode又被称为 统一码、万国码、单一码，它是为了解决传统的字符编码方案的局限性而产生的，它为每种语言中的每个字符设定了统一并且为之一的二进制编码。Unicode规定所有的字符和符号最少由2个字节（16位）来表示，所以Unicode码可以表示的最少字符个数为2**16=65536。

### UTF-8诞生

为什么已经有了Unicode还要UTF-8呢？这是由于当时存储设备是非常昂贵的，而Unicode中规定所有字符最少要由2个字节表示。人们认为像原来ASCII码中的字符用1个字节就可以了，因此人们决定创建一个新的字符编码来节省存储空间。UTF-8是对Unicode编码的压缩和优化，它不在要求最少使用2个字节，而是将所有字符和符号进行分类：

- ascii码中的内容用1个字节保存
- 欧洲的字符用2个字节保存
- 东亚的字符用3个字节保存
- ...

UTF-8是目前最常用，也是被推荐使用的字符编码。

# 计算机运算

## 机器数和真值

### 机器数

一个数在计算机中的二进制表示形式，叫做这个数的机器数。

机器数是带符号的，在计算机用一个数的最高位存放符号，正数为0，负数为1.

比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。

那么，这里的 00000011 和 10000011 就是机器数。

### 真值

机器数的第一位是符号位，后边才是真正的数值，所以机器数的形式值就不等于真正的数值。

例如上面的有符号数10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131(10000011转换成十进制等于131)。

所以，为区别起见，将**带符号位的机器数对应的真正数值称为机器数的真值**。

例：

0000 0001的真值 = +000 0001 = +1

1000 0001的真值 = –000 0001 = –1

## 原码、反码和补码

 原码，反码，补码是机器存储一个具体数字的编码方式。

### 原码

- 定义

​	原码是机器数中最简单的一种表现形式，就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。

​	符号位为0表示正数，符号位为1表示负数，数值位即真值的绝对值，故原码表示又称为**带符号的绝对值表示**。

- 举例

​	比如如果是8位二进制：

​	\[+1](原码) = 0000 0001

​	\[ -1](原码) = 1000 0001

​	第一位是符号位。

​	因为第一位是符号位，所以8位二进制数的取值范围就是：

​	[1111 1111 , 0111 1111]

​	即

​	[-127 , 127]

​	原码是人脑最容易理解和计算的表示方式。

### 反码

- 定义

​	反码的表示方法是: 正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。

- 举例

​	[+1] =\[00000001](原码)= \[00000001](反码)

​	[-1] = \[10000001](原码)= \[11111110](反码)

​	可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码再计算。

### 补码

- 定义

​	补码的表示方法是：正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1 (即在反码的基础上+1)。

- 举例

​	[+1] = \[00000001](原码) = \[00000001](反码) = \[00000001](补码)

​	[-1] = \[10000001](原码) = \[11111110](反码) = \[11111111](补码)

​	对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码在计算其数值。

### 为何要使用原码，反码和补码



## 浮点数运算

### 什么是浮点数

在计算机系统的发展过程中，曾经提出过多种方法表达实数。

1. 定点数(Fixed Point Number)

典型的比如相对于浮点数的`定点数（Fixed Point Number）`。在这种表达方式中，小数点固定的位于实数所有数字中间的某个位置。

货币的表达就可以使用这种方式，比如 99.00 或者 00.99 可以用于表达具有四位精度（Precision），小数点后有两位的货币值。

由于小数点位置固定，所以可以直接用四位数值来表达相应的数值。SQL 中的 NUMBER 数据类型就是利用定点数来定义的。

2. 有理数表达

还有一种提议的表达方式为有理数表达方式，即用两个整数的比值来表达实数。

定点数表达法的缺点在于其形式过于僵硬，固定的小数点位置决定了固定位数的整数部分和小数部分，不利于同时表达特别大的数或者特别小的数。最终，绝大多数现代的计算机系统采纳了所谓的浮点数表达方式。

3. 浮点数表达

浮点数表达方式， 这种表达方式利用`科学计数法`来表达实数，即用`一个尾数（Mantissa ）`，`一个基数（Base）`，`一个指数（Exponent）`以及`一个表示正负的符号`来表达实数。比如 123.45 用十进制科学计数法可以表达为 1.2345 × 10^2 ，其中 1.2345 为尾数，10 为基数，2 为指数。浮点数利用指数达到了浮动小数点的效果，从而可以灵活地表达更大范围的实数。

提示: 尾数有时也称为有效数字（Significand）。**尾数实际上是有效数字的非正式说法。**

同样的数值可以有多种浮点数表达方式，比如上面例子中的 123.45 可以表达为 12.345 × 10^1，0.12345 × 10^3 或者 1.2345 × 10^2。因为这种多样性，有必要对其加以规范化以达到统一表达的目标。

### 浮点数表达

规范的（Normalized）浮点数表达方式具有如下形式：
$$
d.dd...d \times \beta^e , (0 \le d_i < \beta)
$$
 其中 d.dd...d 即尾数，β 为基数，e 为指数。**尾数中数字的个数称为精度**，在本文中用 p（presion） 来表示。每个数字 d 介于 0 和基数β之间，包括 0。小数点左侧的数字不为 0。

1. 基于**规范表达的浮点数**对应的具体值可由下面的表达式计算而得：(p是精度个数)

$$
\pm(d_0 + d_1\beta^{-1} + \dotsm + d_{p-1}\beta^{-(p-1)})\beta^e , (0 \le d_i < \beta)
$$

  对于十进制的浮点数，即基数 β 等于 10 的浮点数而言，上面的表达式非常容易理解，也很直白。计算机内部的数值表达是基于二进制的。从上面的表达式，我们可以知道，二进制数同样可以有小数点，也同样具有类似于十进制的表达方式。只是此时 β 等于 2，而每个数字 d 只能在 0 和 1 之间取值。

2. 比如二进制数 1001.101 相当于：精度为7

$$
1 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times2^{-1} + 0\times2^{-2} + 1\times2^{-3} = 9.625
$$

​	其**规范浮点数**表达为 $1.001101 × 2^3$。

### IEEE （美国电气和电子工程师学会）浮点数

​	计算机中是用**有限的连续字节**保存浮点数的。

　IEEE定义了多种浮点格式，但最常见的是三种类型：**单精度、双精度、扩展双精度**，分别适用于不同的计算要求。一般而言，单精度适合一般计算，双精度适合科学计算，扩展双精度适合高精度计算。一个遵循IEEE 754标准的系统必须支持单精度类型（强制类型）、最好也支持双精度类型（推荐类型），至于扩展双精度类型可以随意。单精度（Single Precision）浮点数是32位（即4字节）的，双精度（Double Precision）浮点数是64位（即8字节）的。

　　保存这些浮点数当然必须有特定的格式，Java 平台上的浮点数类型 float 和 double 采纳了 IEEE 754 标准中所定义的单精度 32 位浮点数和双精度 64 位浮点数的格式。注意: Java 平台还支持该标准定义的两种扩展格式，即 float-extended-exponent 和 double-extended-exponent 扩展格式。这里将不作介绍，有兴趣的读者可以参考相应的参考资料。

　　在 IEEE 标准中，浮点数是将特定长度的连续字节的所有二进制位分割为特定宽度的`符号域`，`指数域`和`尾数域`三个域，其中保存的值分别用于表示给定二进制浮点数中的符号，指数和尾数。这样，通过尾数和可以调节的指数（所以称为"浮点"）就可以表达给定的数值了。

具体的格式参见下面的表格：

|            | 长度 | 符号 | 指数 | 尾数 | 有效位数 | 指数偏移 |    说明     |
| :--------: | :--: | :--: | :--: | :--: | :------: | :------: | :---------: |
|   单精度   | 32位 |  1   |  8   |  23  |    24    |   127    | 有1个隐含位 |
|   双精度   | 64位 |  1   |  11  |  52  |    53    |   1023   | 有1个隐含位 |
| 扩展双精度 | 80位 |  1   |  15  |  64  |    64    |  16383   | 没有隐含位  |

需要特别注意的是，扩展双精度类型没有隐含位，因此它的有效位数与尾数位数一致，而单精度类型和双精度类型均有一个隐含位，因此它的有效位数比位数位数多一个。

- 指数偏移：


![img](https://img-blog.csdn.net/20180508103737785?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlcmNlbF96aGFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![img](https://pic4.zhimg.com/80/v2-17da864450fc6f68f1343dac87c5ab72_720w.jpg?source=1940ef5c)

`IEEE 754` 标准规定一个实数 V 可以用:　　V＝(－1)s×M×2^E的形式表示，说明如下：

　　(1)符号s(sign)决定实数是正数(s＝0)还是负数(s＝1)，对数值0的符号位特殊处理。
　　
　　(2)有效数字M是二进制小数，M的取值范围在1≤M＜2 或 0≤M＜1。
　　
　　(3)指数E（exponent）是2的幂，它的作用是对浮点数加权。

为了强制定义一些特殊值，IEEE标准通过指数将表示空间划分成了三大块：

　　(1)最小值指数（所有位全置0）用于定义0和弱规范数

　　(2)最大指数（所有位全值1）用于定义±∞和NaN（Not a Number）

　　(3)其他指数用于表示常规的数。

　　**这样一来，最大（指绝对值）常规数的指数不是全1的，最小常规数的指数也不是0，而是1。**

![img](https://img-blog.csdn.net/2018050810381680?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RlcmNlbF96aGFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



一个float型实数在内存中占4个字节,即32个二进制bit,从低位到高位依次叫第0位到第31位.

这32位可以分为3个部分：**符号位（第31位）**，阶码（第30位到第23位共8位），**尾数（最低23位）**。

1. 符号位

   最高位也就是第31位表示这个实数是正数还是负数,**为0表示正数或0,为1表示负数**.

2. 阶码

   第30位到第23位这8个二进制位表示该实数转化为规格化的二进制实数后的指数与127(127即所谓偏移量)之和即所谓阶码。
   
   规格化的二进制实数的指数只能在-127----+127之间,所以,一个float型数的最大值在 $+2^{127}$ 即$+3.4*10^{38} $,最小值在 $-2^{127}$ 即 $-3.4*10^{38}$.
   
   **Tips:** 阶码有8位，共256个数，但是 `-127 ~ 127` 只有 255个数是为什么？ 因为 11111111 在阶码中是一个特殊的存在，下面会讲到。

### 四个特殊的数据

- 基本规则

1 11111111 尾数的23位不全为0: 表示不是数值

0 11111111 尾数的23位不全为0: 表示不是数值

- 特殊数据

0 11111111 00000000000000000000000 表示正无穷大

1 11111111 00000000000000000000000 表示负无穷大，比最小负数还小的数都视为负无穷大.

0 11111110 11111111111111111111111 表示最大的正数,  $3.4028235E38 \approx 3.4*10^{38}$

1 11111110 11111111111111111111111 表示最小的负数, $-3.4028235E38 \approx -3.4*10^{38}$

0 00000001 00000000000000000000000 表示最小的正数，$1.0 * 2^{-126} \approx 1.1754944E-38$

1 00000001 00000000000000000000000 表示最大的负数，$-1.0 * 2^{-126} \approx -1.1754944E-38$

0 00000000 00000000000000000000000 表示0



棕上所述，float型数据的表示范围有以下五种(还有别的特殊的就不说了):

$负无穷大; -3.4*10^{38}<x<-1.175*10^{-38}; 0; 1.175*10^{-38)}<x<3.4*10^{38}; 正无穷大.$

### 示例

$2^{-23} \approx .00000011920928955078125$

#### 比较好转换的情况

十进制 178.125 化为 IEEE 754 的 32位 浮点数：

178 ---> 10110010

.125 ---> 001

所以： 178.125 ---> 10110010.001

化为 **规范浮点数** ： $1.0110010001 * 2^7$

公式： $(-1)^S * 2^{P-127}*1.M$

S = 0

P = 134 ---> 10000110

M = 0110010001

内存码：

**0** **10000110** 0000000000000**0110010001**

### 精度丢失

#### 加法出现的丢失

- 单精度 32位

**差距 23位 时：**

0 01111111 00000000000000000000000  ---> 十进制 $2^{127 - 127} = 1$

+

0 10010110 00000000000000000000000  ---> 十进制 $2^{150 - 127} = 8388608$

=

0 10010110 00000000000000000000001 ---> 十进制 

$(1 + 2^{-23}) * 2^{150 - 127} = 8388608 + 1 = 8388608$

**差距 24位 时：**

0 01111111 00000000000000000000000  ---> 十进制 $2^{127 - 127} = 1$

+

0 10010111 00000000000000000000000  ---> 十进制 $2^{151 - 127} = 9007199254740992$

=

0 10010111 00000000000000000000000 ---> 十进制 

$1 * 2^{151 - 127} = 9007199254740992$

**小结：**

当指数偏差位移大于有效数位数时，后面的位数会被舍去。

